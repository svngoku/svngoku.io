"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _pathIsAbsolute = _interopRequireDefault(require("path-is-absolute"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _child_process = require("child_process");

var _LogColors = _interopRequireDefault(require("./LogColors"));

var _Logger = _interopRequireDefault(require("./Logger"));

var _LogLevel = require("./LogLevel");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class HmrServer {
  static defaultReporter({
    context,
    stateValid,
    stats,
    compilerOptions
  }) {
    // for check log level for webpack compiler only
    const compilerLogLevel = (0, _LogLevel.parseLogLevel)(compilerOptions.stats);

    if (!stateValid) {
      if (compilerLogLevel >= _LogLevel.LogLevel.MINIMAL) {
        context.webpackLogger.info('Compiling...');
      }

      return;
    }

    if (compilerLogLevel > _LogLevel.LogLevel.NONE) {
      const statsInfo = stats.toString(compilerOptions.stats);

      if (statsInfo) {
        // To avoid log empty statsInfo, e.g. when options.stats is 'errors-only'.
        context.webpackLogger.info(statsInfo);
      }
    }

    if (compilerLogLevel >= _LogLevel.LogLevel.ERRORS) {
      if (stats.hasErrors()) {
        context.webpackLogger.error('Failed to compile.');
      } else if (stats.hasWarnings()) {
        context.webpackLogger.warn('Compiled with warnings.');
      }
    }

    if (compilerLogLevel >= _LogLevel.LogLevel.MINIMAL) {
      context.webpackLogger.info('Compiled successfully.');
    }
  }

  constructor(_options) {
    _defineProperty(this, "context", {
      /** When started compiled script contain process object in which script running. */
      serverProcess: null,

      /** Valid or invalid state. */
      stateValid: false,

      /** Last compiler stats. */
      webpackStats: undefined,

      /** Compiler watching by compiler.watch(...). */
      watching: undefined,

      /**
       * Don use memory-fs because we can't fork bundle from in-memory file.
       */
      fs: _fs.default,
      reporter: HmrServer.defaultReporter,
      logger: new _Logger.default(_LogColors.default.cyan('[HMR]')),
      webpackLogger: new _Logger.default(_LogColors.default.magenta('Webpack')),
      fork: false,
      compiler: undefined,
      logLevel: undefined
    });

    _defineProperty(this, "sendMessage", action => {
      if (!this.context.serverProcess) {
        return;
      }

      const logLevel = this.context.logLevel != null ? (0, _LogLevel.parseLogLevel)(this.context.logLevel) : (0, _LogLevel.parseLogLevel)(this.context.compiler.options.stats);

      if (this.context.fork) {
        this.context.serverProcess.send({
          action,
          stats: this.context.webpackStats.toJson(),
          logLevel
        });
      } else {
        this.context.serverProcess.emit('message', {
          action,
          stats: this.context.webpackStats.toJson(),
          logLevel
        });
      }
    });

    _defineProperty(this, "launchAssets", stats => {
      const getLauncherFileName = () => {
        const {
          assets
        } = stats.compilation;
        const names = Object.getOwnPropertyNames(assets).filter(k => assets[k].emitted && _path.default.extname(assets[k].existsAt) === '.js');

        if (names.length === 1) {
          // Only one valid assets, so just return it path
          return assets[names[0]].existsAt;
        } // Create temp launcher file which aggregates all assets.


        const launcherString = names.map(k => `require('${assets[k].existsAt.replace(/\\/g, '/')}');`).join('\n');

        const launcherFileName = _path.default.resolve(stats.compilation.compiler.outputPath, `launcher.${stats.hash}.js`);

        this.context.fs.writeFileSync(launcherFileName, launcherString); // Delete created files on exit main process.

        const deleteLauncher = () => this.context.fs.unlinkSync(launcherFileName);

        process.on('exit', deleteLauncher);
        process.on('SIGINT', deleteLauncher);
        return launcherFileName;
      }; // Execute built scripts


      if (this.context.fork) {
        const options = {
          cwd: process.cwd(),
          env: process.env,
          execArgv: this.context.fork === true ? undefined : this.context.fork
        };

        if (process.getuid) {
          options.uid = process.getuid();
          options.gid = process.getgid();
        }

        this.context.serverProcess = (0, _child_process.fork)(getLauncherFileName(), process.argv, options); // Listen for serverProcess events.

        this.context.serverProcess.on('exit', code => {
          // Exit node process when exit serverProcess.
          process.exit(code);
        });
        this.context.logger.info('Launch assets in forked process.');
      } else {
        // Require in current process to lauch script.
        Promise.resolve().then(() => require(`${getLauncherFileName()}`)).then(() => {
          this.context.serverProcess = process;
        }).catch(err => {
          this.context.logger.error(err);
          process.exit();
        });
      }
    });

    _defineProperty(this, "compilerDone", stats => {
      // We are now on valid state
      this.context.stateValid = true;
      this.context.webpackStats = stats; // Do the stuff in nextTick, because bundle may be invalidated
      // if a change happened while compiling

      process.nextTick(() => {
        // check if still in valid state
        if (!this.context.stateValid) return; // print webpack output

        this.context.reporter({
          stateValid: true,
          stats,
          context: this.context,
          compilerOptions: this.context.compiler.options
        });

        if (this.context.serverProcess) {
          this.sendMessage('built');
        } else {
          // Start compiled files in child process (fork) or in current process.
          this.launchAssets(stats);
        }
      });
    });

    _defineProperty(this, "compilerInvalid", (_, callback) => {
      this.sendMessage('compile');

      if (this.context.stateValid) {
        this.context.reporter({
          stateValid: false,
          context: this.context,
          compilerOptions: this.context.compiler.options
        });
      } // We are now in invalid state


      this.context.stateValid = false; // resolve async

      if (typeof callback === 'function') {
        callback();
      }
    });

    _defineProperty(this, "compilerWatch", err => {
      if (err) {
        this.context.logger.error(err.stack || err);
        if (err.details) this.context.logger.error(err.details);
      }
    });

    _defineProperty(this, "startWatch", () => {
      const {
        compiler
      } = this.context; // start watching

      this.context.watching = compiler.watch(compiler.options.watchOptions, this.compilerWatch);
      this.context.logger.info('Waiting webpack...');
    });

    _defineProperty(this, "run", () => {
      const {
        compiler
      } = this.context;

      if (compiler.hooks) {
        // webpack >= 4
        compiler.hooks.done.tap('CompilerDone', this.compilerDone);
        compiler.hooks.compile.tap('ComplierInvalid', this.compilerInvalid);
      } else {
        // webpack < 4
        compiler.plugin('done', this.compilerInvalid);
        compiler.plugin('compile', this.compilerInvalid);
      }

      this.startWatch();
      return this;
    });

    this.context = Object.assign(this.context, _options);
    const {
      compiler: _compiler
    } = this.context;

    if (typeof _compiler.outputPath === 'string' && !_pathIsAbsolute.default.posix(_compiler.outputPath) && !_pathIsAbsolute.default.win32(_compiler.outputPath)) {
      throw new Error('`output.path` needs to be an absolute path or `/`.');
    }
  }

}

exports.default = HmrServer;